@article{Xu2020,
author = {Xu, Yisen and Wu, Fan and Jia, Xiangyang and Li, Lingbo and Xuan, Jifeng},
doi = {10.1007/s10664-020-09842-7},
issn = {1573-7616},
journal = {Empirical Software Engineering},
number = {6},
pages = {4547--4584},
title = {{Mining the use of higher-order functions:}},
url = {https://doi.org/10.1007/s10664-020-09842-7},
volume = {25},
year = {2020}
}
@book{10.5555/1614191,
author = {Cormen, Thomas H and Leiserson, Charles E and Rivest, Ronald L and Stein, Clifford},
edition = {3rd},
isbn = {0262033844},
publisher = {The MIT Press},
title = {{Introduction to Algorithms, Third Edition}},
year = {2009}
}
@misc{Morin2014,
author = {Morin, Pat},
pages = {322},
title = {{Open Data Structures}},
url = {https://opendatastructures.org/},
urldate = {2021-04-28},
year = {2014}
}
@inproceedings{Couderc2020,
address = {New York, NY, USA},
author = {Couderc, Noric and S{\"{o}}derberg, Emma and Reichenbach, Christoph},
booktitle = {ICPE 2020 - Companion of the ACM/SPEC International Conference on Performance Engineering},
doi = {10.1145/3375555.3383760},
isbn = {9781450371094},
keywords = {Java,collections,performance},
month = {apr},
pages = {42--45},
publisher = {Association for Computing Machinery, Inc},
title = {{JBrainy: Micro-benchmarking java collections with interference}},
url = {https://dl.acm.org/doi/10.1145/3375555.3383760},
year = {2020}
}
@inproceedings{Costa2018,
address = {New York, NY, USA},
author = {Costa, Diego and Andrzejak, Artur},
booktitle = {CGO 2018 - Proceedings of the 2018 International Symposium on Code Generation and Optimization},
doi = {10.1145/3168825},
isbn = {9781450356176},
keywords = {Adaptive algorithms,Data structure,Optimization,Performance},
month = {feb},
pages = {16--26},
publisher = {Association for Computing Machinery, Inc},
title = {{CollectionSwitch: A framework for efficient and dynamic collection selection}},
url = {https://dl.acm.org/doi/10.1145/3168825},
volume = {2018-Febru},
year = {2018}
}
@inproceedings{Shacham2009,
abstract = {Languages such as Java and C#, as well as scripting languages like Python, and Ruby, make extensive use of Collection classes. A collection implementation represents a fixed choice in the dimensions of operation time, space utilization, and synchronization. Using the collection in a manner not consistent with this fixed choice can cause significant performance degradation. In this paper, we present CHAMELEON, a low-overhead automatic tool that assists the programmer in choosing the appropriate collection implementation for her application. During program execution, CHAMELEON computes elaborate trace and heap-based metrics on collection behavior. These metrics are consumed on-the-fly by a rules engine which outputs a list of suggested collection adaptation strategies. The tool can apply these corrective strategies automatically or present them to the programmer. We have implemented CHAMELEON on top of a IBM's J9 production JVM, and evaluated it over a small set of benchmarks. We show that for some applications, using CHAMELEON leads to a significant improvement of the memory footprint of the application. Copyright {\textcopyright} 2009 ACM.},
address = {New York, New York, USA},
author = {Shacham, Ohad and Vechev, Martin and Yahav, Eran},
booktitle = {Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)},
doi = {10.1145/1542476.1542522},
file = {:C\:/Users/Peter/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Shacham, Vechev, Yahav - 2009 - Chameleon Adaptive selection of collections.pdf:pdf},
isbn = {9781605583921},
keywords = {Bloat,Collections,Java,Semantic profiler},
pages = {408--418},
publisher = {ACM Press},
title = {{Chameleon: Adaptive selection of collections}},
url = {http://portal.acm.org/citation.cfm?doid=1542476.1542522},
year = {2009}
}
@article{Jung2011,
abstract = {Data structure selection is one of the most critical aspects of developing effective applications. By analyzing data structures' behavior and their interaction with the rest of the application on the underlying architecture, tools can make suggestions for alternative data structures better suited for the program input on which the application runs. Consequently, developers can optimize their data structure usage to make the application conscious of an underlying architecture and a particular program input.This paper presents the design and evaluation of Brainy, a new program analysis tool that automatically selects the best data structure for a given program and its input on a specific microarchitecture. The data structure's interface functions are instrumented to dynamically monitor how the data structure interacts with the application for a given input. The instrumentation records traces of various runtime characteristics including underlying architecture-specific events. These generated traces are analyzed and fed into an offline model, constructed using machine learning, to select the best data structure. That is, Brainy exploits runtime feedback of data structures to model the situation an application runs on, and selects the best data structure for a given application/input/architecture combination based on the constructed model. The empirical evaluation shows that this technique is highly accurate across several real-world applications with various program input sets on two different state-of-the-art microarchitectures. Consequently, Brainy achieved an average performance improvement of 27% and 33% on both microarchitectures, respectively.},
author = {Jung, Changhee and Rus, Silvius and Railing, Brian P. and Clark, Nathan and Pande, Santosh},
doi = {10.1145/1993316.1993509},
file = {:C\:/Users/Peter/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Jung et al. - 2011 - Brainy.pdf:pdf},
issn = {0362-1340},
journal = {ACM SIGPLAN Notices},
keywords = {Algorithms,Application Generator,D23 [Software Engineer-ing]: Coding Tools and Tech,D25 [Testing and Debug-ging]: Diagnostics,D33 [Language Constructs and Features]: Data types,Performance Counters,Performance Keywords Data Structure Selection,Train-ing Framework},
month = {jun},
number = {6},
pages = {86--97},
publisher = {Association for Computing Machinery (ACM)},
title = {{Brainy: effective selection of data structures}},
url = {https://dl.acm.org/doi/10.1145/1993316.1993509},
volume = {46},
year = {2011}
}
@article{Hughes89,
  author    = {John Hughes},
  title     = {Why Functional Programming Matters},
  journal   = {Comput. J.},
  volume    = {32},
  number    = {2},
  pages     = {98--107},
  year      = {1989},
  url       = {https://doi.org/10.1093/comjnl/32.2.98},
  doi       = {10.1093/comjnl/32.2.98},
  timestamp = {Sat, 20 May 2017 00:22:26 +0200},
  biburl    = {https://dblp.org/rec/journals/cj/Hughes89.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@mastersthesis{hovgaard2018higher,
  title="{Higher-Order Functions for a High-Performance Programming Language for GPUs}",
  author={Hovgaard, Anders Kiel},
  year={2018},
  school={Department of Computer Science, University of Copenhagen},
  note = "\url{https://ucph.dk/student-projects/hovgaard-msc-thesis.pdf}",
}

@article{leissa2018anydsl,
  title="{AnyDSL: A Partial Evaluation Framework for Programming High-Performance :ibraries}",
  author={Lei{\ss}a, Roland and Boesche, Klaas and Hack, Sebastian and P{\'e}rard-Gayot, Ars{\`e}ne and Membarth, Richard and Slusallek, Philipp and M{\"u}ller, Andr{\'e} and Schmidt, Bertil},
  journal={Proceedings of the ACM on Programming Languages},
  volume={2},
  number={OOPSLA},
  pages={1--30},
  year={2018},
  publisher={ACM New York, NY, USA}
}

@inproceedings{kuchen2002higher,
  title="{Higher-Order Functions and Partial Applications for a C++ Skeleton Library}",
  author={Kuchen, Herbert and Striegnitz, J{\"o}rg},
  booktitle={Proceedings of the 2002 joint ACM-ISCOPE conference on Java Grande},
  pages={122--130},
  year={2002}
}

@article{michaelson2001nested,
  title={Nested algorithmic skeletons from higher order functions},
  author={Michaelson, Greg and Scaife, Norman and Bristow, Paul and King, Peter},
  journal={Parallel Algorithms and Applications},
  volume={16},
  number={3},
  pages={181--206},
  year={2001},
  publisher={Taylor \& Francis}
}


@inproceedings{MC-HOF-PPDP-2009,
author = {Kobayashi, Naoki},
title = "{Model-Checking Higher-Order Functions}",
year = {2009},
isbn = {9781605585680},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/1599410.1599415},
doi = {10.1145/1599410.1599415},
booktitle = {Proceedings of the 11th ACM SIGPLAN Conference on Principles and Practice of Declarative Programming},
pages = {25–36},
numpages = {12},
keywords = {program verification, model checking, recursion schemes, higher-order functions},
location = {Coimbra, Portugal},
series = {PPDP '09}
}

@inproceedings{T-HORS-POPL-2009,
author = {Kobayashi, Naoki},
title = "{Types and Higher-Order Recursion Schemes for Verification of Higher-Order Programs}",
year = {2009},
isbn = {9781605583792},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1480881.1480933},
doi = {10.1145/1480881.1480933},
booktitle = {Proceedings of the 36th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {416–428},
numpages = {13},
keywords = {higher-order recursion scheme, model checking, type system},
location = {Savannah, GA, USA},
series = {POPL '09}
}

@article{richmond2018synthesizable,
  title="{Synthesizable higher-order functions for C++}",
  author={Richmond, Dustin and Althoff, Alric and Kastner, Ryan},
  journal={IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems},
  volume={37},
  number={11},
  pages={2835--2844},
  year={2018},
  publisher={IEEE}
}

@article{Chin1996,
author="Chin, Wei-Ngan
and Darlington, John",
title="{A Higher-Order Removal Method}",
journal="LISP and Symbolic Computation",
year="1996",
month="Dec",
day="01",
volume="9",
number="4",
pages="287--322",
issn="1573-0557",
doi="10.1007/BF01806315",
url="https://doi.org/10.1007/BF01806315"
}

@inproceedings{dragos2008optimizing,
  title="{Optimizing Higher-Order Functions in Scala}",
  author={Dragos, Iulian},
  booktitle={Third International Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems},
  number={CONF},
  year={2008}
}

@inproceedings{bratvold1992determining,
  title={Determining useful parallelism in higher order functions},
  author={Bratvold, Tore A},
  booktitle={Proceedings of the 4th Int. Workshop on the Parallel Implementation of Functional Languages},
  volume={92},
  year={1992},
  organization={Citeseer}
}

@InProceedings{Fast-HOFsTensors,
author="Bassoy, Cem
and Schatz, Volker",
editor="Shi, Yong
and Fu, Haohuan
and Tian, Yingjie
and Krzhizhanovskaya, Valeria V.
and Lees, Michael Harold
and Dongarra, Jack
and Sloot, Peter M. A.",
title="Fast Higher-Order Functions for Tensor Calculus with Tensors and Subtensors",
booktitle="Computational Science -- ICCS 2018",
year="2018",
publisher="Springer International Publishing",
address="Cham",
pages="639--652",
isbn="978-3-319-93698-7"
}

